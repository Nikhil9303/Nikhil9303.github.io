<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>A Letter to the Sky</title>
<style>
    body, html {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #000;
        color: #fff;
        font-family: 'Courier New', Courier, monospace;
    }

    #background-canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
    }

    .message-container {
        position: fixed;
        bottom: 5vh;
        right: 5vw;
        z-index: 2;
        text-align: right;
        max-width: 90vw;
    }

    /* New silver shine text styling */
    .silver-shine {
        font-size: 0.9em; /* Smaller, cute type */
        font-weight: normal;
        color: #ccc;
        animation: silver-pulse 4s infinite;
    }

    @keyframes silver-pulse {
        0%, 100% { text-shadow: 0 0 3px #fff, 0 0 5px #fff, 0 0 8px #a9a9a9; }
        50% { text-shadow: 0 0 5px #fff, 0 0 8px #fff, 0 0 12px #a9a9a9; }
    }
    
    #shining-text {
        font-weight: bold;
        font-size: 1.5em; /* Siya Jii remains larger */
        color: #ffffff;
    }
    
    #shining-text.glow {
        animation: glowing-gold 2s infinite;
    }
    
    @keyframes glowing-gold {
        0% { color: #FFD700; text-shadow: 0 0 10px #FFD700, 0 0 20px #FFD700, 0 0 30px #FFA500; }
        50% { color: #FFFFFF; text-shadow: 0 0 20px #FFD700, 0 0 30px #FFA500, 0 0 40px #FFA500; }
        100% { color: #FFD700; text-shadow: 0 0 10px #FFD700, 0 0 20px #FFD700, 0 0 30px #FFA500; }
    }
    
    .glowing-btn {
        --glow-color: #ccc; /* Changed to silver */
        --btn-color: #000;
        color: var(--glow-color);
        font-size: 1em;
        font-weight: bold;
        background-color: transparent;
        border: 0.15em solid var(--glow-color);
        border-radius: 0.5em;
        position: relative;
        width: auto;
        padding: 0.6em 1.5em;
        cursor: pointer;
        margin-top: 1.5em;
        letter-spacing: 0.1em;
        transition: all 0.3s;
        overflow: hidden;
    }

    .glowing-btn:hover {
        color: #000;
        background-color: var(--glow-color);
        box-shadow: 0 0 1em 0.2em var(--glow-color);
    }

</style>
</head>
<body>

<canvas id="background-canvas"></canvas>

<div class="message-container">
    <p class="silver-shine">For My Best Friend</p>
    <p class="silver-shine">A special message just for you.</p>
    <p><span id="shining-text">SIYA Jii</span></p>
    
    <button class="glowing-btn" onclick="startAnimations()">
        * SHINE PRINCESS *
    </button>
</div>

<audio id="background-music" src="https://cdn.pixabay.com/download/audio/2022/11/22/audio_51b9a98299.mp3" loop></audio>

<script>
    function startAnimations() {
        const music = document.getElementById('background-music');
        const text = document.getElementById('shining-text');
        
        if (music.paused) {
            music.play();
            text.classList.add('glow');
        } else {
            music.pause();
            text.classList.remove('glow');
        }
    }

    // --- New 3D Wireframe Sphere Background Script ---
    const canvas = document.getElementById('background-canvas');
    const ctx = canvas.getContext('2d');
    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;

    let spheres = [];
    const sphereCount = 5;
    const vertices = 12; 
    const radius = Math.min(width, height) * 0.1;

    let motion = { x: 0, y: 0 };

    function createSphere(x, y, z, r) {
        const points = [];
        for (let i = 0; i < vertices; i++) {
            for (let j = 0; j < vertices; j++) {
                const theta = i / vertices * Math.PI * 2;
                const phi = j / vertices * Math.PI;
                points.push({
                    x: r * Math.sin(phi) * Math.cos(theta),
                    y: r * Math.sin(phi) * Math.sin(theta),
                    z: r * Math.cos(phi)
                });
            }
        }
        return { x, y, z, points, rotation: { x: Math.random() * 0.01, y: Math.random() * 0.01 } };
    }

    function setup() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        spheres = [];
        for (let i = 0; i < sphereCount; i++) {
            spheres.push(createSphere(
                Math.random() * width, 
                Math.random() * height,
                Math.random() * width - width / 2,
                radius * (Math.random() * 0.5 + 0.5)
            ));
        }
    }

    function project(p, sphere) {
        const fov = width * 0.8;
        const projectedZ = p.z + sphere.z + fov - motion.y * 2;
        const scale = fov / projectedZ;
        return {
            x: (p.x + sphere.x - width / 2 - motion.x) * scale + width / 2,
            y: (p.y + sphere.y - height / 2) * scale + height / 2,
            scale: scale
        };
    }

    function draw() {
        ctx.clearRect(0, 0, width, height);
        
        spheres.forEach(sphere => {
            const rotatedPoints = sphere.points.map(p => {
                // Rotate around Y axis
                let x = p.x * Math.cos(sphere.rotation.y) - p.z * Math.sin(sphere.rotation.y);
                let z = p.x * Math.sin(sphere.rotation.y) + p.z * Math.cos(sphere.rotation.y);
                // Rotate around X axis
                let y = p.y * Math.cos(sphere.rotation.x) - z * Math.sin(sphere.rotation.x);
                z = p.y * Math.sin(sphere.rotation.x) + z * Math.cos(sphere.rotation.x);
                return { x, y, z };
            });

            const projectedPoints = rotatedPoints.map(p => project(p, sphere));

            ctx.strokeStyle = `rgba(200, 200, 200, 0.3)`;
            ctx.lineWidth = 1;
            
            for (let i = 0; i < projectedPoints.length; i++) {
                for (let j = i + 1; j < projectedPoints.length; j++) {
                    const p1 = projectedPoints[i];
                    const p2 = projectedPoints[j];
                    const dx = rotatedPoints[i].x - rotatedPoints[j].x;
                    const dy = rotatedPoints[i].y - rotatedPoints[j].y;
                    const dz = rotatedPoints[i].z - rotatedPoints[j].z;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    if (dist < radius * 0.8) {
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    }
                }
            }
            sphere.rotation.x += 0.001;
            sphere.rotation.y += 0.001;
        });

        requestAnimationFrame(draw);
    }
    
    function handleOrientation(event) {
        const beta = event.beta; // Front-back tilt (-180 to 180)
        const gamma = event.gamma; // Left-right tilt (-90 to 90)
        motion.x = gamma * 5;
        motion.y = beta * 3;
    }
    
    function requestMotionPermission() {
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(permissionState => {
                    if (permissionState === 'granted') {
                        window.addEventListener('deviceorientation', handleOrientation);
                    }
                })
                .catch(console.error);
        } else {
            window.addEventListener('deviceorientation', handleOrientation);
        }
        document.body.removeEventListener('click', requestMotionPermission);
    }

    document.body.addEventListener('click', requestMotionPermission, { once: true });
    window.addEventListener('resize', setup);
    setup();
    draw();

</script>

</body>
</html>
